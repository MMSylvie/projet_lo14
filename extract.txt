
1  ===> On créé l'arboresence des répertoires

On sélectionne les lignes qui indique une arborescence

cat test1.arch | grep "directory [A-Za-z0-9]*/"

Resultat:
directory Exemple/Test/
directory Exemple/Test/A
directory Exemple/Test/A/A1
directory Exemple/Test/A/A2
directory Exemple/Test/A/A3
directory Exemple/Test/B

On supprime directory de chaque ligne...

sed "s/directory //g"

Resultat:
Exemple/Test/
Exemple/Test/A
Exemple/Test/A/A1
Exemple/Test/A/A2
Exemple/Test/A/A3
Exemple/Test/B

On créé maintenant une arborescence:

xargs -I {} mkdir -p "{}" < mydirectories.txt


>Au final on éxecute:<

cat test1.arch | grep "directory [A-Za-z0-9]*/" | sed "s/directory //g" > mydirectories.txt

xargs -I {} mkdir -p "{}" < mydirectories.txt

rm -f mydirectories.txt




2   ===> Maintenant on va créer chaque fichier avec leurs droits dans les arborescences corresspondantes

 1) On garde en mémoire le chemin.

 2) Pour chaque ligne entre celle du chemin et la ligne @:
    regarder si les droits commencent par "d" ou "-"

    si les droits commencent par "d", alors le répertoire existe déjà et on lui attribue les droits
    si les droits commencent par "-", alors c'est un fichier, on le créé avec les droits corresspondants


On va utiliser la première ligne des fichiers archives pour sélectionner le contenu intéressant:
head -n 1 => renvoie [debut contenu intéressant]:[fin contenu intéressant + 1 ligne]

              c'est à dire: "3:25"


BEGINNING=`expr $(head -n 1 test1.arch | sed "s/\([0-9]*\):[0-9]*/\1/g") - 1`
$BEGINNING=2

ENDING=`expr $(head -n 1 test1.arch | sed "s/[0-9]*:\([0-9]*\)/\1/g") - 1`
$ENDING=24

CORE=`expr $ENDING - $BEGINNING`

On execute:
head -n $ENDING test1.arch | tail -n $CORE

Résultat:
directory Exemple/Test/
A drwxr-xr-x 4096
B drwxr-xr-x 4096
toto1 -rwxr-xr-x 29 1 3
toto2 -rw-r--r-- 249 4 10
@
directory Exemple/Test/A
A1 drwxr-xr-x 4096
A2 drwxr-xr-x 4096
A3 drwxr-xr-x 4096
toto3 -rw-r--r-- 121 14 3
@
directory Exemple/Test/A/A1
toto4 -rw-r--r-- 0 17 0
@
directory Exemple/Test/A/A2
@
directory Exemple/Test/A/A3
@
directory Exemple/Test/B
bar -rw-r--r-- 202 17 6
@

L'arboresence est contenu dans le fichier mydirectories.txt donc on peut faire parcourir récursivement chaque ligne du fichier mydirectories.txt
et sélectionné dans notre resultat ci-dessus tout ce qui est compris entre $lines et @ et appliquer un traitement dessus à l'aide de la fonction cut:
"si le premier mot de la deuxième colonne est un d, alors, attribuer les droits au répertoire qui se trouve ... et là on concatene la colonne 1 (nom du répertoire) avec $lines soit le chemin."

1) On compte le nombre de ligne du fichier mydirectories.txt.

NUMBER_OF_PATH=$(wc -l mydirectories.txt)

2) Maintenant on cherche à sélectionner tout ce qui est compris entre $lines (du fichier mydirectories) et "@"


##############################



Pour i allant de 1 à $NUMBER_OF_PATH
faire

  #Sélectionne le premier chemin dans lequel on va attribuer des droits et on remplace tous les "/" par "\/" car sinon ça va merder avec awk
  PATH=$(head -n 1 mydirectories.txt | sed 's:/:\\/:g')



fonctionne:

FILES_AND_DIRS_RIGHTS=$(awk -v THE_PATH='Exemple/Test/$' '$0~THE_PATH{flag=1;next}/@/{flag=0} flag' test1.arch)

Résultat:
A drwxr-xr-x 4096
B drwxr-xr-x 4096
toto1 -rwxr-xr-x 29 1 3
toto2 -rw-r--r-- 249 4 10


RIGHTS=$(awk -v THE_PATH='Exemple/Test/$' '$0~THE_PATH{flag=1;next}/@/{flag=0} flag' test1.arch | cut -f2 -d ' ')

Résultat:
drwxr-xr-x
drwxr-xr-x
-rwxr-xr-x
-rw-r--r--


for rights in $RIGHTS
do
  if [[ $rights == d* ]]; then

    chmod u=$USER_RIGHTS,g=GROUP_RIGHTS,o=OTHER_RIGHTS $PATH/$NAME

  else
    touch $PATH/$FILE_NAME
    chmod u=$USER_RIGHTS,g=GROUP_RIGHTS,o=OTHER_RIGHTS $PATH/$NAME
  fi
done
